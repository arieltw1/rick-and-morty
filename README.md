# **Rick and Morty exercise**
A **lazy** walkthrough of building and understanding Ansible-based operators for cloudlets.

testing the operator inside of a pod on a Kubernetes cluster is desired. Running as a pod inside a Kubernetes cluster is preferred for production use.

> **Note:** Before you start working with the content of this repo, make sure to login to the relevant registry and cluster.

## **Prerequisites**
- Bins:
  - helm
  - make
  - kubectl
  - docker
  - python3

- Python modules:
  - tablib==3.0.0
  - requests==2.20.0
  - Flask==2.0.1
  - py_healthcheck==1.10.1

- Images:
	- python:3.8-alpine
	
- User authorized with permissions to create a namespace and manage it.

---
To build and push our image to a registry:

`$ make build push` 


All the variables are set inside the **Makefile** however, most of them can be set on the go.
You can overwrite what is set in the **Makefile**, for example- setting IMG\_TAG parameter like so:

`$ make build push IMG_TAG=v0.0.1`

---
In order to run our image localy for the first time we can run:

`$ make build push run`


When we want to rerun the container using a new image we may run:

`$ make build push rm run`


We can also rerun the container without building and pushing the image again by using:

`$ make rm run IMG_TAG=1.10072021-d2b5e26`

---
Normal manifests deploy to a cluster (not cool):

`$ kubectl create namespace rick-and-morty`

`$ kubectl apply -f yamls/`

---
A better option would be to install our helm chart on the cluster, and that can be achived by running:

`$ helm install Helm/ --generate-name`
or
`$ make deploy`


But if we want to get more fancy we can build, push and deploy our app with only running:

`$ make build push deploy`


If you would like to check the manifests that get generated by helm and go over them you can check the **Helm/debug.yaml** file.
You may also want to deploy that debug file, so you can use:

`$ make debug`


---

## Files structure
  
| **File Name** | **description** |
| --- | --- |
| Dockerfile | Original docker file, used when building in an open environment |
| Makefile | containing a set of directives used by the &#39;make&#39; tool to help build and manage the project automatically |
| requirements.txt | List of the required python modules, used when building the image |
| code/ | the directory which contain all the scripts |
| code/app.py | python flask app listening on 0.0.0.0:8080 |
| code/gen_csv.py | the original script which saves the original data from rick-and-mrty-api inside a csv file |
| code/version.sh | shell script to generate version id (used when building/pushing) |
| yamls/ | the directory which contain all the basic yaml manifest files used to deploy the app |
| Helm/ | the directory which contain all the necesery helm structure files |

## The Deployment

The default Deployment manifest generated for the operator can be found in the **config/manager/manager.yaml** file. By default, the Deployment is named as &#39;controller-manager&#39;. It contains a single container named &#39;manager&#39;, and it may pick up a sidecar patch from the config/default directory. The Deployment will create a single Pod.

For the container in the Pod, there are a few things to note. The default Deployment contains a placeholder for the container image to use, so you cannot create a meaningful operator using the YAML file directly. To deploy the operator, you will **run** `make deploy IMG=<IMG>`. The image name and tag are then patched using kustomize.
